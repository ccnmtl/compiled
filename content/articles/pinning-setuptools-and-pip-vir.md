---
author_name: "Ethan Jucovy"
author_url: "https://github.com/ejucovy/"
date: "2011-04-11"
topics: 
- Process
tags: ["deployment", "django", "process", "python"]
title: "Python Deployment Chronicles: Pinning virtualenv, setuptools and pip"
type: "post"
---

<p>In <a href="http://ccnmtl.columbia.edu/compiled/process/preventing_network_access_with.html">my previous post</a> I talked about how to ensure that none of your Python project's dependencies are being downloaded from the Internet when you create a fresh virtualenv and install them.  This is good for deployments: each deployment is completely reproducible since every package's source is installed from a specific version of the codebase that's versioned alongside the code you're deploying, and deployments don't require external network access to succeed.</p>

<!--more-->

<p>There's one piece that's still missing, though: isolating and pinning the installation of <i>the installation/bootstrapping tools themselves </i>-- virtualenv, pip, and setuptools.</p>

<h2>Virtualenv / Pip Anatomy</h2><p>First, a quick run-through of the relationship between them all. &nbsp; Pip can be made to invoke virtualenv, and invoking virtualenv will install both pip and setuptools, so it's a bit hard to keep it all straight.</p><p>When you create a new virtualenv, the virtualenv tool will pre-install pip and setuptools (or, if you prefer, a setuptools fork called distribute) in your new environment. &nbsp;I'll come back to this fact later in the post.</p>

<p>Meanwhile, you can also create a new virtualenv with pip:</p>

<pre>  $ pip -E /path/to/virtualenv install SomePackage</pre>

<p>That command will install SomePackage into the virtualenv at <code>/path/to/virtualenv</code>, <i>creating the virtualenv at <code>/path/to/virtualenv</code> if it doesn't already exist.</i>&nbsp;&nbsp;At CCNMTL, this has been the entry-point for our bootstrap script; basically we run</p><pre>  $ rm -rf ./ve &amp;&amp; pip -E ./ve install -r requirements.txt</pre><p>on every deployment to create a completely new virtualenv with the needed set of packages installed.</p><p>Where do the pip and virtualenv commands come from, though?</p><p>Virtualenv comes in a convenient single-file version which you can run with the <code>python</code> command of your choice.  Of course you can install it too (using easy_install, pip, your OS packaging system, etc...) but I find it's easier to keep track of if you just grab the file and invoke it with python:</p>

<pre>  $ wget https://github.com/pypa/virtualenv/raw/master/virtualenv.py
  $ python virtualenv.py --help
</pre>

<p>One advantage here is that you can invoke this file with any version of Python, rather than needing to install a separate version for each Python on your system. &nbsp;Another is that you can check that file into your project's code repository, isolate it from the rest of the system, and version it along with your code. &nbsp;In other words, all those advantages of per-project containment.</p><p>The same used to be true of pip -- it came in a single file, pip.py, which you could just grab a copy of, check in to your source repository, and run in your bootstrap script. &nbsp;So this is how we've been doing our deployments at CCNMTL -- each project has its own copy of that pip.py file, and uses it to create a virtualenv and install our project's dependencies.</p><p>Around version 0.7 pip stopped being a single file, and became a package instead. &nbsp;(If you're really interested, that refactoring was discussed&nbsp;<a href="http://groups.google.com/group/python-virtualenv/browse_thread/thread/75e76aa27cf2bd09/" style="text-decoration: underline;">here</a>&nbsp;and implemented&nbsp;<a href="https://github.com/pypa/pip/commit/ef63f2f48f55ab2e110e07cd069e6c0e6c287a2a#pip" style="text-decoration: underline;">starting here</a>.) &nbsp;So, now, you really have to install it somewhere. &nbsp;Of course, as I mentioned above, you'll get a version of pip conveniently installed for you in each new virtualenv you create, so usually you don't even notice this fact.</p><p>At CCNMTL we've avoided this problem so far: all of our projects are still using the old single-file version of pip. &nbsp;Since it's contained and versioned with each project, it's easy <i>not</i> to upgrade, and so far we haven't run into any show-stopping bugs or missing features that would <i>force</i> us to upgrade.</p><meta http-equiv="content-type" content="text/html; charset=utf-8"><p>There are a few messy details though. &nbsp;Unlike virtualenv, pip isn't entirely self-contained -- it relies on a few other non-stdlib Python modules being importable when it runs, including <code><a href="https://github.com/pypa/pip/blob/1.0/pip/venv.py#L25">virtualenv</a></code>, <code><a href="https://github.com/pypa/pip/blob/1.0/pip/commands/install.py#L215">setuptools</a></code> and <code><a href="https://github.com/pypa/pip/blob/1.0/pip/req.py">pkg_resources</a></code> (which comes with Setuptools). &nbsp;At CCNMTL, we've handled that in various ways -- we check in a virtualenv.py file with the source next to the pip.py file, and we usually have setuptools and pkg_resources installed system-wide, even though we rarely use these system-wide installations.</p><p>But, because it's no longer distributed as a single file, and because it requires <i>precisely the modules that Virtualenv provides for you in a fresh environment</i>, it makes more sense to just start deployments from a local, single-file virtualenv.py, rather than from pip:</p><pre>  $ rm -rf ./ve &amp;&amp; python virtualenv.py ./ve
  $ ./ve/bin/pip install -r requirements.txt </pre>

<p>This way you get everything you need, isolated in your virtualenv, without even needing setuptools installed globally. &nbsp;(Indeed, since I started writing this post, <a href="https://github.com/pypa/pip/commit/1b74988671dd459af6723252b7247c369d08f166">this recommendation was added to the pip docs</a>.)</p><h2>Pinning setuptools and pip</h2><p>So, you've checked in a copy of virtualenv.py in your source distribution, and your deployments start by invoking it. &nbsp;So far, so good -- virtualenv.py is now effectively pinned to a known-good version (whichever version you downloaded it at) and, since you've just checked in the file with your project's source, it doesn't require Internet access and is properly versioned alongside your project <a href="http://ccnmtl.columbia.edu/compiled/process/preventing_network_access_with.html">and all its other dependencies</a>.</p><p>But, at this point, you may be wondering how Virtualenv gets setuptools and pip installed if you aren't relying on any system-level packages.</p><p>The answer? &nbsp;It downloads them from the Internet.</p><p>So now we're sort of back where we started -- everything about the bootstrapping process is completely version-pinned, isolated from network dependencies, and self-contained, <i>except for setuptools and pip</i>! &nbsp;They'll still be fetched from PyPI (better hope PyPI's up, and you have network access, during your deployment) and they'll end up installed at their latest released versions (better hope your deployment wasn't relying on some now-unsupported edge-case behavior).</p><p>Luckily, virtualenv has a somewhat hidden feature to get around this: before going to the network to install setuptools and pip, it will <a href="https://github.com/pypa/virtualenv/blob/1.6/virtualenv.py#L556">look for local distributions of each of them in a couple of places</a>, including a directory named <code>virtualenv_support</code>&nbsp;in the same parent directory as your <code>virtualenv.py</code> file. &nbsp;</p><p>This gives us an easy way to pin-and-localize setuptools and pip as well. &nbsp;Grab an appropriate Setuptools <code>.egg</code> (yes, it has to be an <code>.egg</code>, not a tarball) and a pip tarball from their PyPI pages, drop them in a new <code>virtualenv_support</code> directory, and check that in to your project's source repository next to the <code>virtualenv.py</code> file. &nbsp;If for some reason you need an older version of Setuptools or pip, no problem -- just fetch the version you need instead of the latest release.</p><p>Now, finally, your entire project deployment, with all of its dependencies, is versioned alongside your code, pinned to specific versions, and completely isolated from external network access -- including the dependencies of the deployment bootstrapper itself.</p><p><a href="https://github.com/ccnmtl/ccnmtldjango/tree/11618662160cef2fc27fb91d7dfd96bb1dadc6a2/ccnmtldjango/template">Here's an example</a> of what this might look like in a project. &nbsp;The <a href="https://github.com/ccnmtl/ccnmtldjango/tree/11618662160cef2fc27fb91d7dfd96bb1dadc6a2/ccnmtldjango/template/virtualenv_support"><code>virtualenv_support</code> directory</a> contains local copies of setuptools and pip; <a href="https://github.com/ccnmtl/ccnmtldjango/blob/11618662160cef2fc27fb91d7dfd96bb1dadc6a2/ccnmtldjango/template/virtualenv.py">a copy of <code>virtualenv.py</code></a> is located in the same directory as <code>virtualenv_support</code>; and <a href="https://github.com/ccnmtl/ccnmtldjango/blob/11618662160cef2fc27fb91d7dfd96bb1dadc6a2/ccnmtldjango/template/bootstrap.py">a simple bootstrap script</a> creates a fresh virtualenv (implicitly using those local versions of setuptools and pip) and then uses the new virtualenv's <code>pip</code> and <code>easy_install</code> scripts to install the project's requirements, also from <a href="https://github.com/ccnmtl/ccnmtldjango/tree/11618662160cef2fc27fb91d7dfd96bb1dadc6a2/ccnmtldjango/template/requirements">local source distributions</a>.</p>
